<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>CosmWasm for Developers · CosmWasm Documentation</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="# CosmWasm for developers"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="CosmWasm for Developers · CosmWasm Documentation"/><meta property="og:type" content="website"/><meta property="og:url" content="https://cosmwasm.github.io/docs/"/><meta property="og:description" content="# CosmWasm for developers"/><meta property="og:image" content="https://cosmwasm.github.io/docs/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://cosmwasm.github.io/docs/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/docs/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/docs/js/scrollSpy.js"></script><link rel="stylesheet" href="/docs/css/main.css"/><script src="/docs/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/docs/"><img class="logo" src="/docs/img/favicon.ico" alt="CosmWasm Documentation"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/docs/cosmwasm-for-developers.html" target="_self">Docs</a></li><li class=""><a href="/docs/blog" target="_self">Blog</a></li><li class=""><a href="https://github.com/confio/cosmwasm" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Overview</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Overview<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem navListItemActive"><a class="navItem" href="/docs/docs/cosmwasm-for-developers">For Developers</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">CosmWasm for Developers</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="cosmwasm-for-developers"></a><a href="#cosmwasm-for-developers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CosmWasm for developers</h1>
<p>CosmWasm is a new smart contracting platform built for the cosmos ecosystem. If you haven't yet heard of it, please check out this intro (LINK to Michelle's article). The purpose of this article is to give a deep dive into the technology for developers who wish to try it out or integrate it into their product. Particularly, it is aimed at Go developers with experience with the Cosmos-SDK, as well as Rust developers looking for a blockchain platform.</p>
<p>CosmWasm was originally <a href="https://github.com/cosmos-gaians/cosmos-sdk/tree/hackatom/x/contract">prototyped by Team Gaians</a> at the <a href="https://blog.cosmos.network/cosmos-hackatom-berlin-recap-4722882e7623">Berlin Hackatom 2019</a>. In particular, <a href="https://github.com/aaronc">Aaron Craelius</a> came up with the architecture, especially avoiding reentrancy, <a href="https://github.com/jtremback">Jehan Tremback</a> led the rust coding, and <a href="https://github.com/ethanfrey">Ethan Frey</a> led the go side of the implementation. After the successful prototype, the <a href="https://interchain.io/">Interchain Foundation</a> provided a grant to <a href="http://confio.tech">Confio</a> to implement a robust version that would work in an adversarial environment. This article introduces developers to the output of that grant work, and lays out possible future directions.</p>
<h2><a class="anchor" aria-hidden="true" id="how-to-use-cosmwasm"></a><a href="#how-to-use-cosmwasm" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How to use CosmWasm</h2>
<p>CosmWasm is written as a module that can plug into the Cosmos SDK. This means that anyone currently building a blockchain using the Cosmos SDK can quickly and easily add CosmWasm smart contracting support to their chain, without adjusting existing logic. We also provide a sample binary of CosmWasm integrated into the <code>gaiad</code> binary, called <a href="https://github.com/cosmwasm/wasmd">wasmd</a>, so you can launch a new smart-contract enabled blockchain out of the box, using documented and tested tooling and the same security model as the Cosmos Hub.</p>
<p>To try out these commands, you should first install a local single-node testnet of <code>wasmd</code>, by <a href="https://github.com/cosmwasm/wasmd/blob/master/docs/deploy-testnet.md#single-node-local-manual-testnet">following these instructions</a>. Soon we aim to deploy a testnet to allow all developers to quickly test out contract development and connecting dApps.</p>
<h2><a class="anchor" aria-hidden="true" id="deploying-and-using-contracts"></a><a href="#deploying-and-using-contracts" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deploying and Using Contracts</h2>
<p>Once you have a CosmWasm-enabled blockchain, you can deploy a custom contract. This is similar in principle to ethereum, but there are a number of differences in the details. Since most people are familiar with that flow, let us look at some of the main similarities and differences:</p>
<h3><a class="anchor" aria-hidden="true" id="comparision-with-solidity-contracts"></a><a href="#comparision-with-solidity-contracts" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comparision with Solidity Contracts</h3>
<p>First of all, the deploy-exeucte process consists of 3 steps rather than 2. While Ethereum was built around the concept of many unique contracts, each possibly custom-made for any bilateral agreement, the reality seems to show that writing a bug-free contract is harder than originally thought, and a majority are copies of standard templates like OpenZepellin. With that in mind, and conscious of the overhead of uploading and validating wasm code, we define the following 3 phases of a contract:</p>
<ul>
<li>Upload Code - Upload some optimized wasm code, no state nor contract address (example Standard ERC20 contract)</li>
<li>Instantiate Contract - Instantiate a code reference with some initial state, creates new address (example set token name, max issuance, etc for <em>my</em> ERC20 token)</li>
<li>Execute Contract - This may support many different calls, but they are all unprivledged usage of a previously instantiated contract, depends on the contract design (example: Send ERC20 token, grant approval to other contract)</li>
</ul>
<p>Just like ethereum, contract instantiation and execution is metered and requires gas. Furthermore, both instantiation and execution allow the signer to send some tokens to the contract along with the message. Two key differences are that sending tokens directly to a contract, eg. via <code>SendMsg</code>, while possible, <em>does not trigger any contract code</em>. This is a clear design decision to reduce possible attack vectors. It doesn't make anything impossible,  but requires all execution of the contract to be <em>explicitly requested</em>.</p>
<h3><a class="anchor" aria-hidden="true" id="avoiding-reentrancy-attacks"></a><a href="#avoiding-reentrancy-attacks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Avoiding Reentrancy Attacks</h3>
<p>Another big difference is that we avoid all reentrancy attacks by design. This point deserves an article by itself, but in short <a href="https://consensys.github.io/smart-contract-best-practices/known_attacks/">a large class of exploits in Ethereum is based on this trick</a>. The idea is that in the middle of execution of a function on Contract A, it calls a second contract (explicitly or implicitly via send).  This transfers control to contract B, which can now execute code, and call into Contract A again.  Now there are two copies of Contract A running, and unless you are very, very careful about managing state before executing any remote contract or make very strict gas limits in subcalls, this can trigger undefined behavior in Contract A, and a clever hacker can reentrancy this as a basis for exploits, such as the DAO hack.</p>
<p>Cosmwasm avoids this completely by preventing any contract from calling another one directly. Clearly we want to allow composition, but inline function calls to malicious code creates a security nightmare. The approach taken with CosmWasm is to allow any contract to <em>return</em> a list of messages <em>to be executed in the same transaction</em>. This means that a contract can request a send to happen after it is finished (eg. release escrow), or call into other contract. If the future messages fail, then the entire transaction reverts, including updates to the contract's state. This allows to atomic composition and quite a few security guarantees, with the only real downside that you cannot view the results of executing another contract, rather you can just do &quot;revert on error&quot;.</p>
<p>Sometimes we will need information from another contract, and we plan to allow queries to other contracts or the underlying Cosmos SDK modules. These Queries will only have access to a read-only database image and be unable to delegate to other modules, thus avoiding any possible re-entrancy concerns. For more detailed information, please look at the <a href="https://github.com/confio/go-cosmwasm/blob/master/spec/Architecture.md">Architecture documentation</a> as well as the <a href="https://github.com/confio/go-cosmwasm/blob/master/spec/Specification.md">API specification</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="step-by-step-with-a-standard-contract"></a><a href="#step-by-step-with-a-standard-contract" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step by Step with a Standard Contract</h3>
<p>To get this to work, you will need to first deploy a local single-node testnet. I assume you have some experience with this, if not, please refer to gaiad documentation. You will need go 1.13 installed and standard dev tooling, and <code>$HOME/go/bin</code> set to be in your <code>$PATH</code>.</p>
<p><strong>WARNING</strong> The server will only work on osx and linux. Windows support is on the roadmap (but you should be able to use a Windows client).</p>
<p>Checkout code and compile:</p>
<pre><code class="hljs css language-bash">git <span class="hljs-built_in">clone</span> https://github.com/cosmwasm/wasmd.git
<span class="hljs-built_in">cd</span> wasmd
make install
</code></pre>
<p>Set up a single-node local testnet:</p>
<pre><code class="hljs css language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>
wasmd init --chain-id=testing testing

wasmcli keys add validator

wasmd add-genesis-account $(wasmcli keys show validator -a) 1000000000stake,1000000000validatortoken

wasmd gentx --name validator
wasmd collect-gentxs
wasmd start
</code></pre>
<p>Now, open up another window and set up your client:</p>
<pre><code class="hljs css language-bash">wasmcli config chain-id testing
wasmcli config trust-node <span class="hljs-literal">true</span>
wasmcli config node tcp://localhost:26657
wasmcli config output json
wasmcli config indent <span class="hljs-literal">true</span>

wasmcli keys add fred
wasmcli keys add bob
wasmcli keys list

<span class="hljs-comment"># verify initial setup</span>
wasmcli query account $(wasmcli keys show validator -a)
wasmcli query wasm list-code
wasmcli query wasm list-contracts

<span class="hljs-comment"># give some tokens to fred for later</span>
wasmcli tx send $(wasmcli keys show validator -a) $(wasmcli keys show fred -a) 98765stake
wasmcli query account $(wasmcli keys show fred -a)
wasmcli query account $(wasmcli keys show bob -a)
</code></pre>
<p>Now we have a running node and a prepare cli client, let's upload some contracts and let them run. First, we must upload some wasm code that we plan to use in the future. You can download the bytecode to verify it is proper:</p>
<pre><code class="hljs css language-bash">curl -L https://github.com/cosmwasm/wasmd/blob/master/x/wasm/internal/keeper/testdata/contract.wasm?raw=<span class="hljs-literal">true</span> &gt; upload.wasm
wasmcli tx wasm store validator upload.wasm --gas 800000
<span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> stops after one hit</span>
wasmcli query wasm list-code
wasmcli query wasm code 1 download.wasm
sha256sum upload.wasm download.wasm
</code></pre>
<p>We can now create an instance of this wasm contract. Here the verifier will fund an escrow, that will allow fred to control payout and upon release, the funds go to bob.</p>
<pre><code class="hljs css language-bash"><span class="hljs-comment"># instantiate contract and verify</span>
INIT=<span class="hljs-string">"{\"verifier\":\"<span class="hljs-variable">$(wasmcli keys show fred -a)</span>\", \"beneficiary\":\"<span class="hljs-variable">$(wasmcli keys show bob -a)</span>\"}"</span>
wasmcli tx wasm instantiate validator 1 <span class="hljs-string">"<span class="hljs-variable">$INIT</span>"</span> --amount=50000stake

<span class="hljs-comment"># check the contract state (and account balance)</span>
sleep 3
wasmcli query wasm list-contracts
CONTRACT=cosmos18vd8fpwxzck93qlwghaj6arh4p7c5n89uzcee5
wasmcli query wasm contract <span class="hljs-variable">$CONTRACT</span>
wasmcli query wasm contract-state <span class="hljs-variable">$CONTRACT</span>
wasmcli query account <span class="hljs-variable">$CONTRACT</span>
</code></pre>
<p>Once we have the funds in the escrow, let us try to release them. First, failing to do so with a key that is not the verifier, then using the proper key to release:</p>
<pre><code class="hljs css language-bash"><span class="hljs-comment"># execute fails if wrong person</span>
wasmcli tx wasm execute validator <span class="hljs-variable">$CONTRACT</span> <span class="hljs-string">"{}"</span>
sleep 3
wasmcli query tx &lt;<span class="hljs-built_in">hash</span> from above&gt;
wasmcli query account $(wasmcli keys show bob -a)

<span class="hljs-comment"># but succeeds when fred tries</span>
wasmcli tx wasm execute fred <span class="hljs-variable">$CONTRACT</span> <span class="hljs-string">"{}"</span>
sleep 3
wasmcli query account $(wasmcli keys show bob -a)
wasmcli query account <span class="hljs-variable">$CONTRACT</span>
</code></pre>
<p>This is a very simple example for the <a href="https://github.com/confio/cosmwasm/blob/master/contracts/hackatom/src/contract.rs">minimal demo contract</a>, but it should show you what is possible, limited only by the wasm code you upload and the json messages you send.</p>
<h2><a class="anchor" aria-hidden="true" id="resource-limits"></a><a href="#resource-limits" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resource Limits</h2>
<p>Beyond exploits (such as the reentrancy attack), another attack vector for smart contracts is denial of service attacks. A malicious actor could upload a contract that ran an infinite loop to halt the chain. Or wrote tons of data to fill up the disk. Web Assembly provides a tight sandbox with no default access to the OS, so we only need to really worry about providing tight resource limits for the smart contracts. All developers should be aware of these limits.</p>
<p><em>Memory Usage</em> - When instantiating a Wasm VM, it is provided by 32MB of RAM by default. This is to store the byte code as well as all memory used by running the process (stack and heap). This should be plenty large for almost any contract, but maybe some complex zero knowledge circuits would hit limits there. It is also small enough to ensure that contracts have miminal impact of memory usage of the blockchain.</p>
<p><em>CPU Usage</em> - The <a href="https://github.com/wasmerio/wasmer">Wasmer Runtime</a> that we use, has ability to inject metering logic into the wasm code. It calculates prices for various operations and charges and checks limits before every jump statement (loop, function call, etc), to produce a deterministic gas price regardless of cpu speed, platform, etc. Before executing a contract, a wasm gas limit is set based on remaining cosmos sdk gas, and gas deducted at the end of the contract (there is a constant multiplier to convert, currently 100 wasm gas to 1 sdk gas). This puts a hard limit on any CPU computations as you must pay for the cycles used.</p>
<p><em>Disk Usage</em> - All disk access is via reads and writes on the KVStore. The Cosmos SDK already <a href="https://github.com/cosmos/cosmos-sdk/blob/4ffabb65a5c07dbb7010da397535d10927d298c1/store/types/gas.go#L154-L162">enforces gas payments for KVStore access</a>. Since all disk access in the contracts is made via callbacks into the SDK, this is charged there. If one were to integrate CosmWasm in another runtime, you would have to make sure to charge for access there as well.</p>
<h2><a class="anchor" aria-hidden="true" id="writing-contracts-rust"></a><a href="#writing-contracts-rust" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Writing Contracts (Rust)</h2>
<p>Writing your own contract is quite easy if you have a working knowledge of rust.  If you don't, it should still be relatively straightforward to make minor changes to existing contracts, just picking up syntax on the fly. For the rest of this section, however, a basic knowledge of rust is assumed.</p>
<p><a href="https://github.com/confio/cosmwasm">Confio/cosmwasm</a> is a library providing all modular code needed for building a contract. And <a href="https://github.com/confio/cosmwasm-template">cosmwasm-template</a> contains a starter pack to quickly set up a minimal contract along with build system and unit tests, so you can start writing custom logic directly. Both of these libraries offer deeper documentation on how to build them.</p>
<p>To get a feel of how a contract can be built, take a look at the <a href="https://github.com/confio/cosmwasm-examples/blob/master/escrow/src/contract.rs">code for a simple escrow</a>. <a href="https://github.com/confio/cosmwasm-examples/blob/master/escrow/src/contract.rs#L30-L44">State</a> is what is persisted in the database. <a href="https://github.com/confio/cosmwasm-examples/blob/master/escrow/src/contract.rs#L9-L18">InitMsg</a> is sent once to create the contract from the generic code. This contains info on the parties to the escrow, as well as the timeouts. <a href="https://github.com/confio/cosmwasm-examples/blob/master/escrow/src/contract.rs#L20-L28">HandleMsg</a> is an enum containing all possible messages that can be sent. Rather than calling functions directly, we can match on the enum to execute the proper logic for each call. Benefits here are the easy ability to serialize the call, as well as a clear definition of which functions are public.</p>
<p>The <a href="https://github.com/confio/cosmwasm-examples/blob/master/escrow/src/lib.rs#L16-L32">entry points are defined in lib.rs</a>. They handle some standard translations between rust types and the wasm external &quot;ffi&quot; interface, but maintain no real logic there, just allow you to work with <code>Vec&lt;u8&gt;</code> and <code>Result&lt;Response, Error&gt;</code> rather than raw pointers and manually serializing error messages over the ffi boundary. The real logic is in your <code>contract.rs</code> file. <a href="https://github.com/confio/cosmwasm-examples/blob/master/escrow/src/contract.rs#L48-L66">init</a> is the entry point to construct a new contract from this code, and should define all configuration options. <a href="https://github.com/confio/cosmwasm-examples/blob/master/escrow/src/contract.rs#L68-L79">handle</a> loads state and matches over all supported enum values to execute an action on the contract. After which we can <a href="https://github.com/confio/cosmwasm-examples/blob/master/escrow/src/contract.rs#L81-L105">try_approve</a> to release the funds to the beneficiary, or <a href="https://github.com/confio/cosmwasm-examples/blob/master/escrow/src/contract.rs#L107-L126">try_refund</a> to return the funds to the original sender, if the escrow has expired.</p>
<p>Now that we have taken a look at the code, we can try to modify a contract. In this example, adding a backdoor for the contract programmer to steal any tokens in the escrow. Just a fun example and a reminder to validate code before trusting a contract with your tokens.</p>
<p>We will add a new variant to the <code>HandleMsg</code> enum, called <code>Steal</code>, containing a recipeint address. <code>handle</code> will dispatch this message to a <code>try_steal</code> function. This function checks if the signer matches a hardcoded value (in source code) and if so releases all funds to the provided recipient - regardless of the arbiter, and regardless of expiration status.</p>
<p>First try to do this on your own - fork the <a href="https://github.com/confio/cosmwasm-examples">cosmwasm-examples</a> repo and make the changes. Once you have done that, take a look at this video below on how we add the functionality and test it, then compile it, deploy it to testnet, and execute it via the cli.</p>
<p>TODO: show modifying code (backdoor to escrow), then deploy and usage</p>
<h2><a class="anchor" aria-hidden="true" id="deeper-integration-with-your-chain-go"></a><a href="#deeper-integration-with-your-chain-go" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deeper Integration with your Chain (Go)</h2>
<p>Now that we have covered using existing contracts, and developing custom contracts in Rust, let us turn to the potential extensibility on the Go side for experienced Cosmos SDK developers. The provided <a href="https://github.com/cosmwasm/modules/tree/master/incubator/wasm">cosmwasm module</a> is a minimal, unopinionated implementation of bindings between the sdk and the smart contract VM. It takes care of all the implementation details, but leaves the field open for you to fork this module and add custom business logic around it. Below are some ideas on how this could be customized:</p>
<p><em>Add Permissioning or Fees</em> - Are you building a platform where anyone can upload a contract? Or do you intend to use this feature to let on-chain governance add new features without organizing a full chain upgrade process? Consider modifying the handler to deduct fees when uploading code or instantiating a contract. Or maybe just make uploading code a governance handler (proposal type).</p>
<p><em>Add storage limits</em> - Current gas limits in the sdk limit how many reads and writes can be performed in one tx (or one block). However, they do nothing to limit total storage. A contract could eg. write 20 500 byte chunks to disk. And next time another 20, and so on. Since you pass in the KVStore to the contract, you could wrap it with a layer to provide some limitations. Like only one write (or one write to a new key) per contract exection. Or maybe a total limit of keys stored in the contracts KVStore over all executions. Or maybe the creator needs to pre-pay for storage space (buy or rent) and this defines the limits. All this business logic can be writen in go without any changes to the underlying contracts (except preventing some that violate these limits)</p>
<p><em>Support OpaqueMsg</em> - The current CosmWasm spec allows returning an <code>OpaqueMsg</code> variant. This is a message type that is never parsed or created by the smart contract code, just passed through from client to contract to sdk. You can use this for eg. multisigs, where the client proposes some message (maybe a staking issue), which must be approved to be executed with the permissions of the contract. Just as the contract then can dispatch a <code>SendMsg</code>, it can dispatch such an <code>OpaqueMsg</code> as well. This requires no changes in the VM or contracts, but a clear format that the SDK module parses out and then a router with multiple modules to dispatch it to. And then some client side support to construct (unsigned) messages in that format as part of the body of the contract calls. Is it go-amino json of an <code>sdk.Msg</code> implementation? Base64-encoded go-amino binary representation? Or some completely different encoding. As long as your module and your client agree on the format, it is totally opaque to the CosmWasm VM.</p>
<p>Pretty much all the crypto-economic and governance design decisions can be implemented by forking the Go module. If you have ideas, please open issue, or just fork the code and implement it. We at Confio would be happy to discuss any approaches.</p>
<h2><a class="anchor" aria-hidden="true" id="demo"></a><a href="#demo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Demo</h2>
<p>TODO: add screenshare, link to transcript/tutorial</p>
<h2><a class="anchor" aria-hidden="true" id="future-work"></a><a href="#future-work" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Future Work</h2>
<p>CosmWasm, both the VM as well as the platform, is at a usable alpha-state now and we are working on refining the last issues to make it production-ready, with your feedback. Smaller fixes needed to make it ready for mainnet <a href="https://github.com/orgs/confio/projects/1">are being tracked in this project</a>. In addition to that, we want to build tooling around it, and iterate on new features, ideally focused on the needs of real users. Some of the main points on the current roadmap are:</p>
<ul>
<li>Launch and maintain a public testnet, so anyone can experiment with contracts
<ul>
<li>Add support for existing cosmos tools, like block explorer and wallet on this network.</li>
</ul></li>
<li>Build collection of standard contracts to inspire development (like OpenZeppelin)
<ul>
<li>With documentation and tutorials to help onboard new developers</li>
</ul></li>
<li>Create a site to verify rust code behind wasm byte code. (<a href="https://github.com/cosmwasm/cosmos-sdk/issues/9">build system aready built</a>)</li>
<li>Simple JS APIs to instantiate and execute contracts to enable dApp development
<ul>
<li>Also add some demo dapps to go along with demo contracts</li>
</ul></li>
<li>Feedback from community to refine additional features - like query and precompiles</li>
<li>Integrations with more standard modules as requested (eg staking)</li>
</ul>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 11/25/2019 by Ethan Frey</em></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#how-to-use-cosmwasm">How to use CosmWasm</a></li><li><a href="#deploying-and-using-contracts">Deploying and Using Contracts</a><ul class="toc-headings"><li><a href="#comparision-with-solidity-contracts">Comparision with Solidity Contracts</a></li><li><a href="#avoiding-reentrancy-attacks">Avoiding Reentrancy Attacks</a></li><li><a href="#step-by-step-with-a-standard-contract">Step by Step with a Standard Contract</a></li></ul></li><li><a href="#resource-limits">Resource Limits</a></li><li><a href="#writing-contracts-rust">Writing Contracts (Rust)</a></li><li><a href="#deeper-integration-with-your-chain-go">Deeper Integration with your Chain (Go)</a></li><li><a href="#demo">Demo</a></li><li><a href="#future-work">Future Work</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/docs/" class="nav-home"></a><div><h5>Docs</h5><a href="/docs/docs/en/cosmwasm-for-developers.html">Getting Started</a></div><div><h5>Community</h5><a href="https://t.me/joinchat/AkZriEhk9qcRw5A5U2MapA">Telegram</a></div><div><h5>More</h5><a href="/docs/blog">Blog</a><a href="https://github.com/confio/cosmwasm">GitHub</a></div></section><section class="copyright">Copyright © 2019 Confio UO</section></footer></div></body></html>